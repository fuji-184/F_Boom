use std::sync::{Arc};
use std::time::Instant;
use tokio::sync::Semaphore;
use tokio::time::Duration;
use tokio::task::JoinSet;
use crossbeam_channel::unbounded;
use tokio::runtime::Runtime;
use std::collections::HashMap;

struct Data {
    time: Option<Duration>,
    total_send: Option<u64>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (s, r) = unbounded::<Data>();

    let start = Instant::now();

    let runtime = Runtime::new().unwrap();
    runtime.block_on(async {
        let url = "http://127.0.0.1:8080/4";

        let semaphore = Arc::new(Semaphore::new(200));
        let client = Arc::new(
            reqwest::Client::builder()
                .pool_max_idle_per_host(200)
                .pool_idle_timeout(Duration::from_secs(40))
                .timeout(Duration::from_secs(5))
                .build()
                .unwrap(),
        );

        let mut join_set = JoinSet::new();
        let batch_size = 100;
        let max_concurrent = 200;

        let s_ref = s.clone();

        while start.elapsed().as_secs() <= 30 {
            for _ in 0..batch_size {
                if start.elapsed().as_secs() >= 30 {
                    break;
                }

                let client_ref = client.clone();
                let sem_ref = semaphore.clone();
                let s_ref = s_ref.clone();

                join_set.spawn(async move {
                    let _permit = sem_ref.acquire().await.unwrap();

                    let request_start = Instant::now();

                    match client_ref.get(url).send().await {
                        Ok(resp) if resp.status().is_success() => {
                            let data = Data {
                                time: Some(request_start.elapsed()),
                                total_send: None,
                            };
                            s_ref.send(data).unwrap();
                        }
                        _ => {}
                    }
                    let data = Data {
                        time: None,
                        total_send: Some(1),
                    };
                    s_ref.send(data).unwrap();
                });
            }

            while join_set.len() > max_concurrent {
                if let Some(_) = join_set.try_join_next() {
                    continue;
                }
                tokio::task::yield_now().await;
            }
        }

        while let Some(_) = join_set.join_next().await {}
    });

    let duration = start.elapsed();

    drop(s);

    let mut times = vec![];
    let mut total_send = 0;

    for val in r.iter() {
        if let Some(val) = val.time {
            times.push(val.as_nanos() as u64);
        } else if let Some(val) = val.total_send {
            total_send += val;
        }
    }

    times.sort();
    let success = times.len();
    let total_times = times.iter().sum::<u64>();
    let req_per_sec = success as f64 / duration.as_secs_f64();

    let min_time = times.iter().min().unwrap();
    let max_time = times.iter().max().unwrap();

    println!(
        "Success: {}/{} in {:.2} seconds",
        success,
        total_send,
        duration.as_secs_f64()
    );

    println!("Requests per second: {:.2}", req_per_sec);

    if total_send > 0 {
        println!(
            "Success rate: {:.2}%",
            (success as f64 / total_send as f64) * 100.0
        );
    } else {
        println!("Success rate: 0.00%");
    }

    let min_ms = *min_time as f64 / 1_000_000.0;
    let max_ms = *max_time as f64 / 1_000_000.0;
    let avg_ms = (total_times as f64 / success as f64) / 1_000_000.0;

    let median_ms = if success % 2 == 0 {
        let mid = success / 2;
        (times[mid - 1] + times[mid]) as f64 / 2.0 / 1_000_000.0
    } else {
        times[success / 2] as f64 / 1_000_000.0
    };

    let mut freq: HashMap<u64, usize> = HashMap::new();
    for &t in &times {
        *freq.entry(t).or_insert(0) += 1;
    }
    let (mode_val, _) = freq.into_iter().max_by_key(|&(_, count)| count).unwrap();
    let mode_ms = mode_val as f64 / 1_000_000.0;

    let p90_idx = (0.90 * (success as f64 - 1.0)) as usize;
    let p99_idx = (0.99 * (success as f64 - 1.0)) as usize;
    let p90_ms = times[p90_idx] as f64 / 1_000_000.0;
    let p99_ms = times[p99_idx] as f64 / 1_000_000.0;

    println!("Min:    {:.2} ms", min_ms);
    println!("Max:    {:.2} ms", max_ms);
    println!("Avg:    {:.2} ms", avg_ms);
    println!("Median: {:.2} ms", median_ms);
    println!("Mode/Modus:   {:.2} ms", mode_ms);
    println!("p90:    {:.2} ms", p90_ms);
    println!("p99:    {:.2} ms", p99_ms);
    
    let mut buckets = [0u64; 5];

    for t_ns in times.iter() {
        let t_ms = *t_ns / 1_000_000;
        match t_ms {
            0..=50   => buckets[0] += 1,
            51..=100 => buckets[1] += 1,
            101..=150 => buckets[2] += 1,
            151..=200 => buckets[3] += 1,
            _ => buckets[4] += 1,
        }
    }

    println!("0-50ms     : {}", buckets[0]);
    println!("51-100ms   : {}", buckets[1]);
    println!("101-150ms  : {}", buckets[2]);
    println!("151-200ms  : {}", buckets[3]);
    println!("200ms+     : {}", buckets[4]);

    Ok(())
}
