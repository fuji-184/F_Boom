use std::sync::{Arc, atomic::{AtomicU64, Ordering}};
use std::time::Instant;
use tokio::sync::Semaphore;
use tokio::time::Duration;
use tokio::task::JoinSet;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = "http://127.0.0.1:8080/4";
    
    let start = Instant::now();
    let success = Arc::new(AtomicU64::new(0));
    let total = Arc::new(AtomicU64::new(0));
    
    let min = Arc::new(AtomicU64::new(u64::MAX));
    let max = Arc::new(AtomicU64::new(0));
    let total_time = Arc::new(AtomicU64::new(0));
    
    let semaphore = Arc::new(Semaphore::new(200));
    let client = Arc::new(
        reqwest::Client::builder()
            .pool_max_idle_per_host(200)
            .pool_idle_timeout(Duration::from_secs(40))
            .timeout(Duration::from_secs(5))
            .build()?,
    );

    let mut join_set = JoinSet::new();
    let batch_size = 100;
    let max_concurrent = 200;
    let mut spawned_total = 0u64;

    while start.elapsed().as_secs() <= 30 {
        for _ in 0..batch_size {
            if start.elapsed().as_secs() >= 30 {
                break;
            }

            let client_ref = client.clone();
            let success_ref = success.clone();
            let total_ref = total.clone();
            let sem_ref = semaphore.clone();
            
            let min_ref = min.clone();
            let max_ref = max.clone();
            let total_time_ref = total_time.clone();

            join_set.spawn(async move {
                let _permit = sem_ref.acquire().await.unwrap();

                let request_start = Instant::now();

                match client_ref.get(url).send().await {
                    Ok(resp) if resp.status().is_success() => {
                        
                       
                        
                        
                        success_ref.fetch_add(1, Ordering::Relaxed);
                        
                        let time = request_start.elapsed();
                        let atomic_time = time.as_nanos() as u64;
                        
                        min_ref.fetch_min(atomic_time, Ordering::Relaxed);
                        max_ref.fetch_max(atomic_time, Ordering::Relaxed);
                        total_time_ref.fetch_add(atomic_time, Ordering::Relaxed);
                        
                        
                    }
                    _ => {}
                }
                total_ref.fetch_add(1, Ordering::Relaxed);
            });

            spawned_total += 1;
        }

        while join_set.len() > max_concurrent {
            if let Some(_) = join_set.try_join_next() {
                continue;
            }
            tokio::task::yield_now().await;
        }
    }

    while let Some(_) = join_set.join_next().await {}

    let duration = start.elapsed();
    let total_requests = total.load(Ordering::Relaxed);
    let success_requests = success.load(Ordering::Relaxed);
    let req_per_sec = success_requests as f64 / duration.as_secs_f64();
    
    let min_time = min.load(Ordering::Relaxed);
    let max_time = max.load(Ordering::Relaxed);
    let total_time2 = total_time.load(Ordering::Relaxed);
    
    println!(
        "Success: {}/{} in {:.2} seconds",
        success_requests,
        total_requests,
        duration.as_secs_f64()
    );
    
    println!("Requests per second: {:.2}", req_per_sec);
    
    if total_requests > 0 {
        println!(
            "Success rate: {:.2}%",
            (success_requests as f64 / total_requests as f64) * 100.0
        );
    } else {
        println!("Success rate: 0.00%");
    }

    println!("Total spawned: {}", spawned_total);
    
    if min_time == u64::MAX {
            println!("No latency data collected");
        } else {
            let min_ms = min_time as f64 / 1_000_000.0;
            let max_ms = max_time as f64 / 1_000_000.0;
            let avg_ms = (total_time2 as f64 / total_requests as f64) / 1_000_000.0;
            
            println!("Min:  {:.2} ms", min_ms);
            println!("Max:  {:.2} ms", max_ms);
            println!("Avg:  {:.2} ms", avg_ms);
        }

    Ok(())
}